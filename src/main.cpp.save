#define GLEW_STATIC
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include "Time.h"
#include "TextureManager.h"
#include "Render.h"
#include "Sprite.h"
#include "Scene.h"
#include "EASScripts.h"
#include "TextGenerator.h"
#include "Canvas.h"
#include "ButtonUI.h"
#include "ImageUI.h"
#include "ProgresBarUI.h"
//test
#include <sys/types.h>
#include <dirent.h>
#include <cmath>
#include <wchar.h>
#define PI 3.14159265
//test

static int sd = 50;
static float speed = 2.f;
static bool physAct = false;
static float t = 0.f;

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) {
    if(key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
    	glfwSetWindowShouldClose(window, GL_TRUE);
    if(key == GLFW_KEY_SPACE && action == GLFW_PRESS)
    	physAct = !physAct;
}

void mouse_callback(GLFWwindow* window, int button, int action, int mode) {
    if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS) {
        int width, height;
        glfwGetFramebufferSize(window, &width, &height);
        double xpos, ypos;
        glfwGetCursorPos(window, &xpos, &ypos);
        if((0 * width < xpos && 0.25f * width > xpos) && (0 * height < ypos && 0.25f *height > ypos))
            physAct = !physAct;//std::cout << xpos << "!" << ypos << std::endl;

        if((0.25f * width < xpos && 0.5f * width > xpos) && (0 * height < ypos && 0.25f *height > ypos))
            t = 0.f;
    }
}

int main() {
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);

	GLFWwindow* window = glfwCreateWindow(800, 800, "OpenGL", nullptr, nullptr);
    if (window == nullptr)
    {
        std::cout << "ERROR::GLFW::WINDOW" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetKeyCallback(window, key_callback);
    glfwSetMouseButtonCallback(window, mouse_callback);

    glewExperimental = GL_TRUE;
    if (glewInit() != GLEW_OK)
    {
        std::cout << "ERROR::GLEW" << std::endl;
        glfwTerminate();
        return -2;
    }

    Time* time = new Time();
    TextureManager* tm = new TextureManager();

    EASScripts* easScript = new EASScripts(tm);
    easScript->loadTexture(tm);
    tm->loadTexts();
    map<string, Scene> loadedScenes;
    Scene secScene;


    int width, height;
    glfwGetFramebufferSize(window, &width, &height);

    glViewport(0, 0, width, height);

    //TEST
    Camera cam(glm::vec3(0.0f, 0.0f, 1.0f));
    Render curr(width, height, tm);
    curr.setCam(cam);
    Sprite sp1("sp1");
    sp1.setTexture("Box");
    int oheight = height;
    sp1.x = 100; sp1.y = oheight - 100; sp1.z = -1; sp1.sx = 50; sp1.sy = 50;
    Sprite sp2("sp2");
    sp2.setTexture("Dirt");
    sp2.x = 500; sp2.y = oheight + 25; sp2.z = -2; sp2.sx = 1500; sp2.sy = 200;


    Canvas can(tm, width, height);

    can.addLayout("-1", "X4W", 0, 0, 0.5f,0.75f);
    can.addLayout("-1", "XIMG", 0.5f, 0.0f, 0.0f, 0.75f);
    can.addLayout("X4W", "X1/4W", 0.0f, 0.0f, 0.5f, 0.0f);
    can.addLayout("-1", "X4/1W", 0.25f, 0.0f, 0.5f, 0.75f);
    can.addLayout("-1", "XPB", 0.5f, 0.75f, 0.0f, 0.0f);

    ButtonUI tb("MyButton");
    tb.backColor = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f);
    tb.pressColor = glm::vec4(1.0f, 0.0f, 0.0f, 1.0f);
    tb.hoveredColor = glm::vec4(0.0f, 1.0f, 0.0f, 1.0f);
    tb.background = "ButtTest";
    tb.text = "";
    can.addElement("X1/4W", tb);

    ButtonUI tbu("MyButton2");
    tbu.backColor = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f);
    tbu.pressColor = glm::vec4(0.3984375f, 0.3984375f, 0.3984375f, 1.0f);
    tbu.hoveredColor = glm::vec4(1.0f, 1.0f, 0.8f, 1.0f);
    tbu.background = "ButtTest";
    tbu.text = "";
    tbu.active = true;
    can.addElement("X4/1W", tbu);

    ImageUI ti("MyImage");
    ti.background = "ImgPanel";
    can.addElement("XIMG", ti);

    ProgresBarUI* tpb = new ProgresBarUI("PB");
    tpb->background = "PBB";
    tpb->foreground = "PBF";
    //tpb->prozent = 30.f;
    //tpb->side = 4;
    //tpb->side = 1;
    tpb = can.addElement("XPB", *tpb);

    int i = 0;
    float gt = 0;
    int angle = 30;
    float sa = sin(angle * PI / 180);
    float ca = cos(angle * PI / 180);
    float Vo = 20.f;
    float tp = (Vo / 4.9f) * sa;
    //TEST--------------

    while(!glfwWindowShouldClose(window))
    {
        time->startFrame();

        if(i<15) {
            i++;
        }

        glfwGetFramebufferSize(window, &width, &height);
        glViewport(0, 0, width, height);
        curr.resizeW(width, height);

        glfwPollEvents();

        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glDepthFunc(GL_LESS);

        curr.RenderSprite(&sp1);
        curr.RenderSprite(&sp2);

        //TEST UI
        //glActiveTexture(GL_TEXTURE0);
        //glBindTexture(GL_TEXTURE_2D, testText);
        glDepthFunc(GL_ALWAYS);
        can.Draw(&curr, window);
        //curr.RenderUI(can.getLayout("X1/4W")->preModel);
        //--------------------------------

        //Test physic block
        if(i > 10)
            gt += time->getDeltaTime();

        if(t != tp) {
            if(t < tp) {
                if(physAct)
                    t += gt;
            }else{
                t = tp;
            }

            tpb->prozent = t / tp * 100;

            gt = 0;

            //std::cout << tp << std::endl;
            float y = Vo * sa * t - 4.9f * t * t;
            //std::cout << y * 100 << std::endl;
            float x = Vo * ca * t;
            //std::cout << x * 100 << std::endl;

            sp1.x = 100 + x * 15.0f;
            sp1.y = oheight - 100 - (y * 15.0f);
        }
        //Test physic block

        if (glfwGetKey(window, GLFW_KEY_R) == GLFW_PRESS) {
            t = 0;
        }

        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
            tpb->side++;
            if(tpb->side > 4)
                tpb->side = 1;
        }

        curr.getCam()->updateCameraVectors();

        glfwSwapBuffers(window);
        time->endFrame();
    }

    time->~Time();
    glfwTerminate();
	return 0;
}
