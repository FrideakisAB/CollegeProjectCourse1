#include "TextureManager.h"

TextureManager::TextureManager()
{
    LoadTexture("PBB", "resources/textures/prog_back.png", 4);
    LoadTexture("PBF", "resources/textures/prog_front.png", 4);
    LoadShader("UIProgresBar", "UI", "UIProgressBar");

    int error = FT_Init_FreeType( &this->library );
    if ( error )
    {
        std::cout << "ERROR::FREETYPE" << std::endl;
    }

    //LoadText("pause", L"Пауза", "Kornilow", 50, glm::vec3(0,0,0));
}

void TextureManager::loadTexts() {
    
}

TextureManager::~TextureManager()
{

}

void TextureManager::LoadTexture(string n, string p, int mode) {
    int w;
    int h;
    int comp;
    unsigned char* image = stbi_load(p.c_str(), &w, &h, &comp, mode);

    if(image == nullptr)
        throw(std::string("Failed to load texture"));

    glGenTextures(1, &this->spriteT[n]);

    glBindTexture(GL_TEXTURE_2D, this->spriteT[n]);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

    if(comp == 3)
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
    else if(comp == 4)
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);

    glBindTexture(GL_TEXTURE_2D, 0);

    stbi_image_free(image);
}

void TextureManager::LoadShader(string n, string pe) {
    this->shaders[n] = new Shader(string("resources/shaders/" + pe + "Vertex.glsl").c_str(), string("resources/shaders/" + pe + "Fragment.glsl").c_str());
}

void TextureManager::LoadShader(string n, string p1, string p2) {
    this->shaders[n] = new Shader(string("resources/shaders/" + p1 + "Vertex.glsl").c_str(), string("resources/shaders/" + p2 + "Fragment.glsl").c_str());
}

GLuint TextureManager::getSprite(string name) {
    return this->spriteT[name];
}

GLuint TextureManager::getTextImage(string name) {
    return this->texts[name];
}

Shader* TextureManager::getShader(string name) {
    return this->shaders[name];
}

void TextureManager::LoadFont(string name, string font) {
    int error = FT_New_Face(library, string("resources/fonts/" + font + ".ttf").c_str(), 0, &this->fonts[name]);
    if ( error == FT_Err_Unknown_File_Format )
    {
        std::cout << "ERROR::FREETYPE::FACE::FORMAT" << std::endl;
    }
    else if ( error )
    {
       std::cout << "ERROR::FREETYPE::FACE" << std::endl;
    }
}

void TextureManager::LoadText(string name, wstring text, string font, int fontSize, glm::vec3 color, int align=1, int vert=1, int space=4) {
    FT_Set_Pixel_Sizes (this->fonts[font], 0, fontSize);

	FT_Glyph glyph;

	int w = 0;
	unsigned int h = 0;
	unsigned int maxh = 0;
	unsigned int toprow = 0;

	const wchar_t* es = text.c_str();
	int len = wcslen(es);

        /* первое что я придумал это посчитать какую текстуру вообще надо создать, но для этого
         * мне пришлось создать каждый символ и узнать его ширину. Так я вижу полную картину. Знаю
         * какой массив создать */
	for(int i = 0; i < len; i++) {
		wchar_t charcode = es[i];
                /* далее идут стандартные операции для создания bitmap символа */
		FT_Load_Char (this->fonts[font], charcode, FT_LOAD_RENDER);

		FT_UInt glyph_index = FT_Get_Char_Index(this->fonts[font], charcode);
		FT_Load_Glyph (this->fonts[font], glyph_index, FT_LOAD_DEFAULT);
		FT_Render_Glyph (this->fonts[font]->glyph, FT_RENDER_MODE_NORMAL);
		FT_Get_Glyph (this->fonts[font]->glyph, &glyph);

		FT_Glyph_To_Bitmap (&glyph, FT_RENDER_MODE_NORMAL, 0, 1);
		FT_BitmapGlyph bitmap_glyph = (FT_BitmapGlyph)glyph;
		FT_Bitmap bitmap = bitmap_glyph->bitmap;
                /* теперь надо узнать ширину символа */
		w += bitmap.width;

                /* узнать разницу высоты шрифта и отступа от верха. */
		int resize = bitmap.rows > bitmap_glyph->top ? bitmap.rows - bitmap_glyph->top : bitmap_glyph->top - bitmap.rows;
                /* теперь высота значиться как высота символа плюс отступ */
        if(h < bitmap.rows + resize)
            h = bitmap.rows + resize;
                /* здесь надо знать самую большую высоту символа */
		if(toprow < bitmap.rows)
            toprow = bitmap.rows;
		if(maxh < bitmap.rows + bitmap_glyph->top)
            maxh = bitmap.rows + bitmap_glyph->top;

                /* если символ равен пробелу, то увеличить w на столько пикселей, сколько задали при
                 * инициализации */
		if(charcode == ' ')
            w += space;
                /* если встретился символ 'новая строка'
                 * то увеличить высоту включив туда вертикальный отступ и максимальную высоту */
		if(charcode == '\n') {
			h += vert + maxh;
			FT_Done_Glyph(glyph);
			continue;
		}
                /* это расстояние между шрифтом, если align равен одному пикселю, то увеличиться на один */
		w += align;

		FT_Done_Glyph(glyph);
	}

        /* теперь можно создать подготовительный двухмерный массив,
         * он включает размер всего текста в пикселях */
    if (h <= 0)
        h = maxh;
	uint8_t im[h][w];
        /* заполню нулями массив */
	memset(&im[0][0], 0, w * h * sizeof(uint8_t));

	int ih = 0;
	int iw = 0;
	int posy = 0;
	int topy = 0;
	int maxwidth = 0;
	for(int i = 0; i < len; i++) {
		wchar_t charcode = es[i];
		FT_Load_Char(this->fonts[font], charcode, FT_LOAD_RENDER);
		FT_UInt glyph_index = FT_Get_Char_Index (this->fonts[font], charcode);

		FT_Load_Glyph(this->fonts[font], glyph_index, FT_LOAD_DEFAULT);
		FT_Render_Glyph(this->fonts[font]->glyph, FT_RENDER_MODE_NORMAL);
		FT_Get_Glyph(this->fonts[font]->glyph, &glyph);

		FT_Glyph_To_Bitmap(&glyph, FT_RENDER_MODE_NORMAL, 0, 1);
		FT_BitmapGlyph bitmap_glyph = (FT_BitmapGlyph)glyph;
		FT_Bitmap bitmap = bitmap_glyph->bitmap;

                /* получить отступ символа от верха */
		posy = bitmap_glyph->top;
                /* это математика наверное, немогу объяснить как я тут высчитал */
		posy = bitmap.rows - posy;
        topy = toprow - bitmap.rows;

                /* если новая строка, то ih - это высота от верха, то есть сверху это ноль,
                 * ниже увеличивается */
		if(charcode == '\n') {
			ih += maxh;
			iw = 0;
			FT_Done_Glyph(glyph);
			continue;
		}
		for( unsigned int y = 0, i = 0; y < bitmap.rows; y++ ) {
			for( unsigned int x = 0; x < bitmap.width; x++, i++ ) {
                if((ih + posy + y + topy) > h) {
                    if(posy < 0)
                        posy = abs(posy);
                }

                                /* здесь заполняется в нужное место один компонент цвета
                                 * пока массив из одного компонента gray, потом его перенесем в альфа канал */
				im[ih + posy + y + topy][iw + x] = bitmap.buffer[i];
			}
		}
                /* увеличиваем ширину */
		iw += bitmap.width;
                /* увеличиваем расстояние между символами */
		iw += align;
		if(maxwidth < iw)
            maxwidth = iw;

		if(charcode == ' ') {
			iw += space;
		}

		FT_Done_Glyph(glyph);

	}

	iw = maxwidth;
	int width = iw;
	int height = h;

	unsigned int size = width * height;
        /* а вот это уже будущая текстура */
	uint8_t *image_data = new uint8_t[size * 4];
        /* заполняет белым цветом всю текстуру */
	memset(image_data, 255, size * 4 * sizeof(uint8_t));

	for(unsigned int i = 0, y = 0; i < size; y++) {
		for(int x = 0; x < width; x++, i++) {
                        /* сюда помещаем из нашего массива значение в альфа канал */
			image_data[ 4 * i + 3] = im [y][x];
                        /* сюда цвет текста */
			image_data[ 4 * i + 0] = color.x;
			image_data[ 4 * i + 1] = color.y;
			image_data[ 4 * i + 2] = color.z;
		}
	}

	GLuint textureid;
        /* стандартные действия для заполнения текстуры */
	glGenTextures(1, &textureid);
	glBindTexture(GL_TEXTURE_2D, textureid);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        /* теперь нужно задать размер текстуры */
	//setSize ( width, height );
        /* и удалить текстуру, она уже загружена в буфер и image_data больше не требуется. */
	delete[] image_data;

	//return textureid;
	this->texts[name] = textureid;
}
